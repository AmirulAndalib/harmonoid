// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'media_player_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MediaPlayerState {
  int get index => throw _privateConstructorUsedError;
  List<Playable> get playables => throw _privateConstructorUsedError;
  double get rate => throw _privateConstructorUsedError;
  double get pitch => throw _privateConstructorUsedError;
  double get volume => throw _privateConstructorUsedError;
  bool get shuffle => throw _privateConstructorUsedError;
  Loop get loop => throw _privateConstructorUsedError;
  Duration get position => throw _privateConstructorUsedError;
  Duration get duration => throw _privateConstructorUsedError;
  bool get playing => throw _privateConstructorUsedError;
  bool get buffering => throw _privateConstructorUsedError;
  bool get completed => throw _privateConstructorUsedError;
  double get audioBitrate => throw _privateConstructorUsedError;
  AudioParams get audioParams => throw _privateConstructorUsedError;

  /// Create a copy of MediaPlayerState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MediaPlayerStateCopyWith<MediaPlayerState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MediaPlayerStateCopyWith<$Res> {
  factory $MediaPlayerStateCopyWith(
          MediaPlayerState value, $Res Function(MediaPlayerState) then) =
      _$MediaPlayerStateCopyWithImpl<$Res, MediaPlayerState>;
  @useResult
  $Res call(
      {int index,
      List<Playable> playables,
      double rate,
      double pitch,
      double volume,
      bool shuffle,
      Loop loop,
      Duration position,
      Duration duration,
      bool playing,
      bool buffering,
      bool completed,
      double audioBitrate,
      AudioParams audioParams});
}

/// @nodoc
class _$MediaPlayerStateCopyWithImpl<$Res, $Val extends MediaPlayerState>
    implements $MediaPlayerStateCopyWith<$Res> {
  _$MediaPlayerStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MediaPlayerState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? playables = null,
    Object? rate = null,
    Object? pitch = null,
    Object? volume = null,
    Object? shuffle = null,
    Object? loop = null,
    Object? position = null,
    Object? duration = null,
    Object? playing = null,
    Object? buffering = null,
    Object? completed = null,
    Object? audioBitrate = null,
    Object? audioParams = null,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      playables: null == playables
          ? _value.playables
          : playables // ignore: cast_nullable_to_non_nullable
              as List<Playable>,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as double,
      pitch: null == pitch
          ? _value.pitch
          : pitch // ignore: cast_nullable_to_non_nullable
              as double,
      volume: null == volume
          ? _value.volume
          : volume // ignore: cast_nullable_to_non_nullable
              as double,
      shuffle: null == shuffle
          ? _value.shuffle
          : shuffle // ignore: cast_nullable_to_non_nullable
              as bool,
      loop: null == loop
          ? _value.loop
          : loop // ignore: cast_nullable_to_non_nullable
              as Loop,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as Duration,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
      playing: null == playing
          ? _value.playing
          : playing // ignore: cast_nullable_to_non_nullable
              as bool,
      buffering: null == buffering
          ? _value.buffering
          : buffering // ignore: cast_nullable_to_non_nullable
              as bool,
      completed: null == completed
          ? _value.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as bool,
      audioBitrate: null == audioBitrate
          ? _value.audioBitrate
          : audioBitrate // ignore: cast_nullable_to_non_nullable
              as double,
      audioParams: null == audioParams
          ? _value.audioParams
          : audioParams // ignore: cast_nullable_to_non_nullable
              as AudioParams,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MediaPlayerStateImplCopyWith<$Res>
    implements $MediaPlayerStateCopyWith<$Res> {
  factory _$$MediaPlayerStateImplCopyWith(_$MediaPlayerStateImpl value,
          $Res Function(_$MediaPlayerStateImpl) then) =
      __$$MediaPlayerStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      List<Playable> playables,
      double rate,
      double pitch,
      double volume,
      bool shuffle,
      Loop loop,
      Duration position,
      Duration duration,
      bool playing,
      bool buffering,
      bool completed,
      double audioBitrate,
      AudioParams audioParams});
}

/// @nodoc
class __$$MediaPlayerStateImplCopyWithImpl<$Res>
    extends _$MediaPlayerStateCopyWithImpl<$Res, _$MediaPlayerStateImpl>
    implements _$$MediaPlayerStateImplCopyWith<$Res> {
  __$$MediaPlayerStateImplCopyWithImpl(_$MediaPlayerStateImpl _value,
      $Res Function(_$MediaPlayerStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of MediaPlayerState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? playables = null,
    Object? rate = null,
    Object? pitch = null,
    Object? volume = null,
    Object? shuffle = null,
    Object? loop = null,
    Object? position = null,
    Object? duration = null,
    Object? playing = null,
    Object? buffering = null,
    Object? completed = null,
    Object? audioBitrate = null,
    Object? audioParams = null,
  }) {
    return _then(_$MediaPlayerStateImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      playables: null == playables
          ? _value._playables
          : playables // ignore: cast_nullable_to_non_nullable
              as List<Playable>,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as double,
      pitch: null == pitch
          ? _value.pitch
          : pitch // ignore: cast_nullable_to_non_nullable
              as double,
      volume: null == volume
          ? _value.volume
          : volume // ignore: cast_nullable_to_non_nullable
              as double,
      shuffle: null == shuffle
          ? _value.shuffle
          : shuffle // ignore: cast_nullable_to_non_nullable
              as bool,
      loop: null == loop
          ? _value.loop
          : loop // ignore: cast_nullable_to_non_nullable
              as Loop,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as Duration,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
      playing: null == playing
          ? _value.playing
          : playing // ignore: cast_nullable_to_non_nullable
              as bool,
      buffering: null == buffering
          ? _value.buffering
          : buffering // ignore: cast_nullable_to_non_nullable
              as bool,
      completed: null == completed
          ? _value.completed
          : completed // ignore: cast_nullable_to_non_nullable
              as bool,
      audioBitrate: null == audioBitrate
          ? _value.audioBitrate
          : audioBitrate // ignore: cast_nullable_to_non_nullable
              as double,
      audioParams: null == audioParams
          ? _value.audioParams
          : audioParams // ignore: cast_nullable_to_non_nullable
              as AudioParams,
    ));
  }
}

/// @nodoc

class _$MediaPlayerStateImpl implements _MediaPlayerState {
  const _$MediaPlayerStateImpl(
      {required this.index,
      required final List<Playable> playables,
      required this.rate,
      required this.pitch,
      required this.volume,
      required this.shuffle,
      required this.loop,
      required this.position,
      required this.duration,
      required this.playing,
      required this.buffering,
      required this.completed,
      required this.audioBitrate,
      required this.audioParams})
      : _playables = playables;

  @override
  final int index;
  final List<Playable> _playables;
  @override
  List<Playable> get playables {
    if (_playables is EqualUnmodifiableListView) return _playables;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_playables);
  }

  @override
  final double rate;
  @override
  final double pitch;
  @override
  final double volume;
  @override
  final bool shuffle;
  @override
  final Loop loop;
  @override
  final Duration position;
  @override
  final Duration duration;
  @override
  final bool playing;
  @override
  final bool buffering;
  @override
  final bool completed;
  @override
  final double audioBitrate;
  @override
  final AudioParams audioParams;

  @override
  String toString() {
    return 'MediaPlayerState(index: $index, playables: $playables, rate: $rate, pitch: $pitch, volume: $volume, shuffle: $shuffle, loop: $loop, position: $position, duration: $duration, playing: $playing, buffering: $buffering, completed: $completed, audioBitrate: $audioBitrate, audioParams: $audioParams)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MediaPlayerStateImpl &&
            (identical(other.index, index) || other.index == index) &&
            const DeepCollectionEquality()
                .equals(other._playables, _playables) &&
            (identical(other.rate, rate) || other.rate == rate) &&
            (identical(other.pitch, pitch) || other.pitch == pitch) &&
            (identical(other.volume, volume) || other.volume == volume) &&
            (identical(other.shuffle, shuffle) || other.shuffle == shuffle) &&
            (identical(other.loop, loop) || other.loop == loop) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.playing, playing) || other.playing == playing) &&
            (identical(other.buffering, buffering) ||
                other.buffering == buffering) &&
            (identical(other.completed, completed) ||
                other.completed == completed) &&
            (identical(other.audioBitrate, audioBitrate) ||
                other.audioBitrate == audioBitrate) &&
            (identical(other.audioParams, audioParams) ||
                other.audioParams == audioParams));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      index,
      const DeepCollectionEquality().hash(_playables),
      rate,
      pitch,
      volume,
      shuffle,
      loop,
      position,
      duration,
      playing,
      buffering,
      completed,
      audioBitrate,
      audioParams);

  /// Create a copy of MediaPlayerState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MediaPlayerStateImplCopyWith<_$MediaPlayerStateImpl> get copyWith =>
      __$$MediaPlayerStateImplCopyWithImpl<_$MediaPlayerStateImpl>(
          this, _$identity);
}

abstract class _MediaPlayerState implements MediaPlayerState {
  const factory _MediaPlayerState(
      {required final int index,
      required final List<Playable> playables,
      required final double rate,
      required final double pitch,
      required final double volume,
      required final bool shuffle,
      required final Loop loop,
      required final Duration position,
      required final Duration duration,
      required final bool playing,
      required final bool buffering,
      required final bool completed,
      required final double audioBitrate,
      required final AudioParams audioParams}) = _$MediaPlayerStateImpl;

  @override
  int get index;
  @override
  List<Playable> get playables;
  @override
  double get rate;
  @override
  double get pitch;
  @override
  double get volume;
  @override
  bool get shuffle;
  @override
  Loop get loop;
  @override
  Duration get position;
  @override
  Duration get duration;
  @override
  bool get playing;
  @override
  bool get buffering;
  @override
  bool get completed;
  @override
  double get audioBitrate;
  @override
  AudioParams get audioParams;

  /// Create a copy of MediaPlayerState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MediaPlayerStateImplCopyWith<_$MediaPlayerStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
